@page "/app/settings"

<PageTitle>Settings</PageTitle>

<MudPaper Class="pa-6" Elevation="2">
    <MudText Typo="Typo.h5" GutterBottom="true">Client Settings</MudText>
    <MudDivider Class="my-4" />
    <MudGrid>
        <!-- Theme -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">Theme</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudSwitch T="bool" @bind-Checked="_isDark" Color="Color.Primary" Label="Dark Mode" />
                </MudCardContent>
                <MudCardActions>
                    <MudButton OnClick="SaveThemeAsync" Color="Color.Primary" Variant="Variant.Filled">Save</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
        <!-- Cache -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">API Cache</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudText>Clear the in-memory GET response cache.</MudText>
                </MudCardContent>
                <MudCardActions>
                    <MudButton OnClick="ClearCache" Color="Color.Error" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.DeleteSweep">Clear Cache</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
        <!-- Offline Queue -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">Offline Queue</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudText>@($"{_queued.Count} queued request(s)")</MudText>
                    <MudTable Dense="true" Bordered="true" Hover="true" Items="_queued">
                        <HeaderContent>
                            <MudTh>Method</MudTh>
                            <MudTh>Url</MudTh>
                            <MudTh>Age (s)</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Method">@context.Method</MudTd>
                            <MudTd DataLabel="Url" Style="max-width:250px;overflow:hidden;text-overflow:ellipsis;">@context.Url</MudTd>
                            <MudTd DataLabel="Age">@((int)(DateTime.UtcNow - context.CreatedUtc).TotalSeconds)</MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudCardContent>
                <MudCardActions>
                    <MudButton Disabled="_queued.Count==0 || !_online" OnClick="ManualSync" Color="Color.Primary" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.CloudSync">Sync Now</MudButton>
                    <MudButton Disabled="_queued.Count==0" OnClick="ClearQueue" Color="Color.Error" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.ClearAll">Clear Queue</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
        <!-- Status -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">Status</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudChip T="KeyValuePair<string,double>" Color="@(_online?Color.Success:Color.Error)" Variant="Variant.Filled" StartIcon="@(_online?Icons.Material.Filled.Cloud:Icons.Material.Filled.CloudOff)">@(_online?"Online":"Offline")</MudChip>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <!-- Feature Flags -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">Feature Flags</MudText>
                </MudCardHeader>
                <MudCardContent>
                    @if (_featureFlags.Count == 0)
                    {
                        <MudText Typo="Typo.caption">Loading flags...</MudText>
                    }
                    else
                    {
                        @foreach (var flag in _featureFlags)
                        {
                            <MudSwitch T="bool" Checked="flag.Value" Color="Color.Primary" OnChanged="@GetFlagChangedCallback(flag.Key)" Label="@flag.Key" Class="d-block my-1" />
                        }
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>
        <!-- Shortcuts -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader>
                    <MudText Typo="Typo.subtitle1">Keyboard Shortcuts</MudText>
                </MudCardHeader>
                <MudCardContent>
                    <MudTable Dense="true" Hover="true" Items="_shortcuts">
                        <HeaderContent>
                            <MudTh>Key</MudTh>
                            <MudTh>Description</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Key">@context.Key</MudTd>
                            <MudTd DataLabel="Description">@context.Description</MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <!-- NEW: Usage Metrics Snapshot -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader><MudText Typo="Typo.subtitle1">Usage Metrics</MudText></MudCardHeader>
                <MudCardContent>
                    <MudTable Dense="true" Items="_metricsEntries">
                        <HeaderContent><MudTh>Metric</MudTh><MudTh>Value</MudTh></HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Metric">@context.Key</MudTd>
                            <MudTd DataLabel="Value">@context.Value</MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudCardContent>
                <MudCardActions>
                    <MudButton OnClick="RefreshMetrics" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Refresh">Refresh</MudButton>
                    <MudButton OnClick="ExportMetrics" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Download">Export CSV</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
        <!-- NEW: Push Notifications (placeholder) -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader><MudText Typo="Typo.subtitle1">Push Notifications</MudText></MudCardHeader>
                <MudCardContent>
                    @if(!_pushSupported)
                    {
                        <MudAlert Severity="Severity.Info" Dense Variant="Variant.Outlined">Push not supported in this environment.</MudAlert>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2">Permission: @_pushPermission</MudText>
                    }
                </MudCardContent>
                <MudCardActions>
                    <MudButton Disabled="@(!_pushSupported)" OnClick="RequestPush" StartIcon="@Icons.Material.Filled.NotificationsActive">Request Permission</MudButton>
                    <MudButton Disabled="@(!CanSubscribePush)" OnClick="SubscribePush" StartIcon="@Icons.Material.Filled.Subscriptions">Subscribe</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
        <!-- NEW: Impersonation -->
        <MudItem xs="12" md="6">
            <MudCard>
                <MudCardHeader><MudText Typo="Typo.subtitle1">Impersonation</MudText></MudCardHeader>
                <MudCardContent>
                    @if(_isImpersonating)
                    {
                        <MudAlert Severity="Severity.Warning" Dense>You are impersonating another user. Original: @_originalUserId</MudAlert>
                    }
                    <MudTextField @bind-Value="_impersonateTarget" Label="Target User Id" Disabled="_isImpersonating" />
                </MudCardContent>
                <MudCardActions>
                    <MudButton Disabled="_isImpersonating || string.IsNullOrWhiteSpace(_impersonateTarget)" OnClick="StartImpersonation" Color="Color.Warning" StartIcon="@Icons.Material.Filled.PersonSearch">Start</MudButton>
                    <MudButton Disabled="!_isImpersonating" OnClick="EndImpersonation" Color="Color.Success" StartIcon="@Icons.Material.Filled.StopCircle">End</MudButton>
                </MudCardActions>
            </MudCard>
        </MudItem>
    </MudGrid>
</MudPaper>

@code {
    [Inject] private IClientPreferenceManager Prefs { get; set; } = default!;
    [Inject] private IApiCacheService Cache { get; set; } = default!;
    [Inject] private INetworkStatusService Network { get; set; } = default!;
    [Inject] private IOfflineRequestQueue OfflineQueue { get; set; } = default!;
    [Inject] private IFeatureFlagService FeatureFlags { get; set; } = default!;
    [Inject] private IShortcutService ShortcutService { get; set; } = default!;
    [Inject] private ILocalizationService L10N { get; set; } = default!;
    [Inject] private IUsageMeterService Usage { get; set; } = default!;
    [Inject] private IExportService Exporter { get; set; } = default!;
    [Inject] private IPushNotificationService Push { get; set; } = default!;
    [Inject] private IImpersonationService Impersonation { get; set; } = default!;
    [Inject] private IJSRuntime Js { get; set; } = default!;

    private bool _isDark;
    private bool _online;
    private List<QueuedRequest> _queued = new();
    private Dictionary<string,bool> _featureFlags = new();
    private List<ShortcutDescriptor> _shortcuts = new();
    private string _currentCulture = "en-US";
    private string _selectedCulture = "en-US";
    private IEnumerable<string> _cultures = Array.Empty<string>();
    private List<KeyValuePair<string,double>> _metricsEntries = new();
    private bool _pushSupported;
    private string _pushPermission = "unknown";
    private bool _isImpersonating;
    private string? _originalUserId;
    private string? _impersonateTarget;

    private bool CanSubscribePush => _pushSupported && _pushPermission == "granted";

    /// <summary>
    /// Initializes the settings page and loads all required data.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        var pref = await Prefs.GetPreference() as ClientPreference ?? new ClientPreference();
        _isDark = pref.IsDarkMode;
        await Network.InitializeAsync();
        _online = Network.IsOnline;
        Network.StatusChanged += s => { _online = s; InvokeAsync(StateHasChanged); };
        _queued = (await OfflineQueue.GetAllAsync()).ToList();
        await FeatureFlags.InitializeAsync();
        _featureFlags = FeatureFlags.All().ToDictionary(k=>k.Key,v=>v.Value);
        _shortcuts = ShortcutService.All().OrderBy(s=>s.Key).ToList();
        RefreshMetrics();
        _pushSupported = Push.IsSupported;
        _isImpersonating = Impersonation.IsImpersonating;
        _originalUserId = Impersonation.OriginalUserId;
    }

    private async Task SaveThemeAsync()
    {
        var pref = await Prefs.GetPreference() as ClientPreference ?? new ClientPreference();
        pref.IsDarkMode = _isDark;
        await Prefs.SetPreference(pref);
        Toast.Add("Theme updated. Reload if not applied.", Severity.Success);
    }

    private void ClearCache()
    {
        Cache.Clear();
        Toast.Add("API cache cleared.", Severity.Success);
    }

    private async Task ManualSync()
    {
        if (!_online)
        {
            Toast.Add("Offline.", Severity.Warning);
            return;
        }
        await OfflineQueue.FlushAsync(async qr =>
        {
            try
            {
                using var http = new HttpClient();
                var msg = new HttpRequestMessage(new HttpMethod(qr.Method), qr.Url);
                if (qr.Body != null)
                {
                    msg.Content = new StringContent(qr.Body, System.Text.Encoding.UTF8,
                        qr.Headers.TryGetValue("Content-Type", out var ct) ? ct : "application/json");
                }
                foreach (var h in qr.Headers)
                {
                    if (h.Key.Equals("Content-Type", StringComparison.OrdinalIgnoreCase)) continue;
                    msg.Headers.TryAddWithoutValidation(h.Key, h.Value);
                }
                var resp = await http.SendAsync(msg);
                return resp.IsSuccessStatusCode;
            }
            catch { return false; }
        });
        _queued = (await OfflineQueue.GetAllAsync()).ToList();
        Toast.Add("Sync attempted.", Severity.Info);
    }

    private async Task ClearQueue()
    {
        await OfflineQueue.ClearAsync();
        _queued.Clear();
        Toast.Add("Queue cleared.", Severity.Success);
    }

    private async Task ToggleFlag(string flag, bool enabled)
    {
        await FeatureFlags.SetAsync(flag, enabled);
        _featureFlags[flag] = enabled;
        Toast.Add($"Flag '{flag}' set to {enabled}", Severity.Success);
    }
    
    private void RefreshMetrics()
    {
        _metricsEntries = Usage.Snapshot().OrderBy(k=>k.Key).ToList();
    }

    private async Task ExportMetrics()
    {
        var rows = _metricsEntries.Select(k=> new { k.Key, k.Value, Timestamp = DateTime.UtcNow });
        var bytes = await Exporter.ExportCsvAsync(rows);
        await Js.InvokeVoidAsync("fshDownload.saveFile", "metrics.csv", Convert.ToBase64String(bytes));
    }

    private async Task RequestPush()
    {
        var granted = await Push.RequestPermissionAsync();
        _pushPermission = granted ? "granted" : "denied";
        Toast.Add($"Push permission: {_pushPermission}", granted ? Severity.Success : Severity.Error);
    }

    private async Task SubscribePush()
    {
        await Push.SubscribeAsync();
        Toast.Add("Subscribed (placeholder).", Severity.Success);
    }

    private async Task StartImpersonation()
    {
        await Impersonation.StartAsync(_impersonateTarget!);
        _isImpersonating = true; _originalUserId = Impersonation.OriginalUserId;
        Toast.Add("Impersonation started.", Severity.Warning);
    }

    private async Task EndImpersonation()
    {
        await Impersonation.EndAsync();
        _isImpersonating = false; _originalUserId = null; _impersonateTarget = null;
        Toast.Add("Impersonation ended.", Severity.Success);
    }

    private EventCallback<bool> GetFlagChangedCallback(string key)
    {
        return EventCallback.Factory.Create<bool>(this, value => ToggleFlag(key, value));
    }
}
